# 说明
- 添加新功能不用修改原有的代码;
- 新功能是基于类某时刻的状态进行, 对于并发类型, 需要注意设计安全;
> 有点类似回调`callback`, 输入是具体的对象, 类似`this`;

# 案例
> 比如有一个树型数据`(语法树之类的)`, 语法树具体类型可能有赋值, 语句, 变量等; 对于这些, 需要添加额外的功能;
> 对接口进行添加, 那么就需要每一个子类都要实现; 这种添加比较麻烦; 修改可能很多, 需要修改的位置也可能很多;

- 局限性: 状态型的; 可能需要用到状态模式, 然后校验, 这种需要知晓细节;

> 编译器对于语法树, 可以添加`visitor`进行源代码分析优化, 错误就直接提示, 或者`pretty print`之类的操作;

- 语法树抽象: 具体类`(赋值语句, 执行语句, 分支语句等)`;
> 上面有提到, 直接加功能会有很多问题; 相似的代码不整合在一起, 修改可能有遗漏;
> 而且每一次修改头文件, 会导致依赖的地方被修改, 而且添加是静态添加, 编译阶段添加; 而不是动态, 也不灵活;
> 所以用`visitor`隔离开就会很好;

# 应用场景
- 对一系列 **固定数量的具体** 类进行操作;
> 这些类只需要统一继承实现一个`accept`接口即可; 甚至可以不用统一继承; 即只需要添加一个接受`visitor`的函数; 只是大部分是统一的;
- 一些不相关的操作直接加到类里面可能会污染原有的类, 可以将其进行隔离, 使用`visitor`;
- 类的数量固定, 但是需要经常加新功能;
> 接口上加功能会让每一个子类都加, 修改头文件和实现, 这种就比较麻烦; 改动很大;

# `visitor`的一些事实
### 添加新的功能方便
- `visitor`可以被添加为友元类, 但是就是完全的白盒, 深度介入; 即基于类数据的状态进行某些操作;
- 外放成员, 采用函数的形式, 就需要添加很多函数, 需要注意生命周期等问题, 可能更加复杂;

### 解偶
- 将相关代码都统一实现在一个`visitor`里, 不相关的则拆分;
- 不相关的拆分是实现到具体的类中; 即在类中加函数;
- 统一放在一起方便修改, 添加新的数据结构, 也不会污染已有的结构;

### 添加新的处理类麻烦
- 添加新的类就会出现所有的`visitor`实现和接口都需要修改, 虽说接口添加可以添加默认实现, 但是行为不统一;
- 偶尔添加类: 可以使用, 比如小版本升级更新;
- 经常添加类: 每天, 一周, 一个月这种, 可能就应该考虑是否该实现到具体类中;

### 不同的类都可以统一处理
- 可以添加一些`visitor`, 遍历, 然后在循环体中进行执行, 如果统一接口, 就可以再加一个循环;
```cpp
Visitor *v1 = new Visitor1();
Visitor *v2 = new Visitor2();
Visitor *v3 = new Visitor3();
Visitor *v4 = new Visitor4();

std::vector<Visitor> vs {v1, v2, v3, v4};

Element1 e1;
Element2 e2;

for (const auto & i : vs) {
    e1.visit(i);
    e2.visit(i);
}
// 或者是 下面的, 执行顺序不同;

for (const auto & i : vs) {
    e1.visit(i);
}

for (const auto & i : vs) {
    e2.visit(i);
}

```

### 状态累积
- 即状态变化可以通过`visitor`进行保存, 每一个处理`class`对应一个状态纪录成员, 或者其他类似的方案;
```cpp
class V2 : public Visitor {
public:
    std::any Element1_stat;
    void process(Element1 * e1) {
        Element1_stat = e1->stat();
    }
};
```
- 如果没有, 就需要额外的参数; 来保存处理;

### 破坏封装
- 因为处理的是具体类, 所以一般是`friend`, 直接对内部数据进行操作读取处理;
- 带来的问题就是, 面向实现, 就不是面向抽象, 而且完全的了解, 甚至如成员函数一样;

# 实现
```cpp
class Obj1 : public Object {
public:
    // 这里的 this 就是 Obj1 类型, 在编译阶段就可以知晓; 只是 vist 调用的具体对象是多肽;
    void accept(Visitor* vist) override {
        vist->visit(this);
    }
    void print() override {
        std::cout << __FILE__ << " "  << __LINE__ << std::endl;
    }
};
```

### `Double-dispatch`
- 根据 **输入参数的实际类型** 和 **当前对象的实际参数类型** ;
- 根据输入和执行实际类型, 确认实际的执行函数;
- 会有性能的开销, 以及复杂度;

### `Who is responsible for traversing the object structure?`
- 怎么遍历`object`集合;
> 选项有三: `obj`内部便利, 再调用`visit`进行添加功能; `visitor`中遍历, 结合上下文直接操作元素; 单独`iter`进行;
- 经常是`obj`内部自行遍历; 另一种是`obj`提供迭代器, `visitor`使用提供的`iter`进行


# 总结
### 加功能`(第一参数就是 this)`, 类的数量变化小, 但是经常加功能, 外放;
### `callback` + 每一个具体类实现`accept`, 调用`visitor`对应的函数;