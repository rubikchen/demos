# 简介
### 参考
[https://mp.weixin.qq.com/s/dNg1CymE13_uHe9bQsCL-g](https://mp.weixin.qq.com/s/dNg1CymE13_uHe9bQsCL-g)

### 就跟建筑一样, 为了各种目的形成方案, 并记录
- 设计模式不是只有这几种, 针对不同的问题和需求, 设计的解决方案不同;

### 分类
- `Creational Patterns`: 创建型, 一个或一组对象被创建的多种形式;
- `Structural Patterns`: 结构型, 怎么通过一个或多个对象形成一个更大, 功能更复杂的对象;
- `Behavioral Patterns`: 行为型, 怎么设计从设计模式角度, 设计函数的输入和输出参数; 对象与对象之间如何灵活交互;

### 多态
- 基于多态, 灵活变化, 实现执行时的变化; 根据某些参数变化, 场景变化算法;


# 创建型
### `Abstract Factory`: 一个工厂会分开生产一个产品的不同零件; 不同零件不同函数生产; 最终可组合;
- 抽象工厂: 工厂定义了多种零件; 具体工厂生产一批不同类型零件, 这些零件可以在同一个工厂中任意交互; 如果不行, 则建议再抽象拆分;

### `Builder`: 着重有限的零件拼装多种产品, 或一种产品的多种形态;
- 创建无法一次性创建完, `builder`类似参数缓冲对象; 然后一次性结合多个参数进行创建一个成品类;
- 比如创建一个买手机功能: 可以输入多种筛选条件, 然后生成最终筛选器, 最终生成的筛选器一起执行;

### `Factory Method`: 不和实体类打交道, 修改实体类不影响抽象逻辑;
- 将创建具体的对象交给子类; 比如`android`的`activity`就是, 具体的`view`由子类确认;
- 一般是写框架用到;

### `prototype`: 拷贝的形式生成对象
- `clone`的实现, 即深浅拷贝的形式生成对象;

### `Singleton`: 全局生命周期
- 单例模式, 最好不要单例, 对于一些可能出现多实例创建的, 需要谨慎; 要考虑竞争问题, 后续多实例的可能;

# 结构型
### `adapter`: `AB`不能凑一块, 加个适配器`(拓展坞)`就可以了; 一种临时补救措施, 一般涉及到的工作量不大;
- 将`A`转换成`B`, 但是`A`要支持`B`的行为; 不然就不适合转换;

### `Bridge`: 依赖抽象, 而不是依赖实体; 即成员变量不要依赖具体类;
- 如何通过多个对象形成一个最后对象; 这里就体现了组合生成一个大的对象;

### `Composite`: 部分整体的关系; 树形结构;
- 多个对象生成更大对象; 比如语法树;

### `Decorator`: 增加新的特性`(包装, 完整的包裹, 每一个接口都有包装)`
- 一层层的包装, 生成一个最终的产物; 比如给汉堡包打包, 生成一个方便携带的汉堡包`(本质还是汉堡包)`, 行为不能发生变化; 即也可以替代;
- 一般是用来加额外的条件的; 是添加额外的组合, 和责任链都是链, 但是一个着重责任`(可能不会都执行)`, 一个着重添加新的组件`(一定都会执行)`;

### `Façade`: 将复杂的内部, 简化成对外接口`(不一定是组合成一个大的)`
- 外观模式, 将复杂的系统外放给三方进行编程, 比如算法sdk, 标准库里的文件`IO`系列接口;

### `Flyweight`: 池, 针对大量资源的对象服用;
- 可以理解为对象池, 一般是用于大型分配比较耗时的对象;

### `Proxy`: 按需分配
- 一般是按需创建; 即真正使用的时候才创建; 比如外部调用`init`阶段只创建对象; 并异步进行初始化;

# 行为型
### `Chain of Responsibility`
- 一个请求, 多个进行判断, 可能随时短路;
- 一定要注意状态和生命周期管理;

### `Command`: 事件驱动, 一般用于`UI`
- 可以提供对外自定义的操作, 比如UI框架对开发者, 用户自定义行为机制;
- 输入统一, 封装一个可调用对象;
- 可调用对象里面有其他的对象; 这就是`Command`和集合对象和其他之间的交互;

### `Interpreter`
- 解释器: 开发自己的一门语言, 比如正则表达式; 也可以开发一个自己的小型脚本;

### `Iterator`: 对外提供集合迭代集合, 迭代器的生命周期需要小于等于集合本身; 还需要注意迭代器失效, 即其他操作导致原来指向的地址和原来不同;
- 迭代器: 集合对外提供便利方式; 即`A`对象提供`B`对象给`C`对象访问`A`对象的内容;

### `Mediator`
- 不同的对象根据统一输入信息进行交互处理;

### `Memento`
- 备忘: `A`对象提供`B`对象的内部数据状态备份; 都有点类似拷贝了;

### `Observer`
- 观察者模式: 中央集权, 订阅和提醒; 参考`epoll`

### `State`
- 状态模式: 对外提供状态对象;
- 状态确认, 以及状态之间切换是否合法的一种检查类;

### `Strategy`
- 策略模式: `A`的逻辑依赖`B`的抽象, 但是`B`可以随时被替换, 每个替换的`B`都可以提供相似但本质一样的行为;

### `Template Method`
- 模板方法: 对外提供一个可自定义的行为, 大的逻辑一样; 也是写框架的人通常用到;

### `Visitor`
- 在实体类数量不经常变化, 但是需要经常添加新函数的场景使用;
